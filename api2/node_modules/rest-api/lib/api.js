var connect = require('connect');
var http = require('http');
var fs = require('fs');
var path = require('path');
var util = require('util');
var _ = require('underscore');

var middlewareCors = require('./middleware/cors.js');
var middlewareRouter = require('./middleware/router.js');
var middlewareCall = require('./middleware/call.js');
var middlewareRender = require('./middleware/render.js');
var middlewareError = require('./middleware/error.js');
var middlewareHooks = require('./middleware/hooks.js');
var middlewareResponse = require('./middleware/response.js');
var middlewareJsonp = require('./middleware/jsonp.js');


// GLOBALS
// ------------------------
HTTP_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'CONNECT', 'PATCH'];
FORMATS = {json: 'application/json', text: 'text/plain'};

ClientError = function(obj) {
  Error.captureStackTrace(this);
  this.name = 'ClientError';
  this.status = obj.status;
  this.message = obj.message || '';
}
util.inherits(ClientError, Error);
// ------------------------



function api(options) {
  // Invokes with new if called without
  if (false === (this instanceof api)) {
    return new api(options);
  }

  var defaults = {
    port: 8080,
    accessLog: false,
    errorLog: './error_log',
    controllers: './controllers',
    cors: true,
    jsonp: true,
    headersResponseTime: false
  };

  this.options = _.defaults(options, defaults);
  this.controllers = null;
  this.handles = {};
  this.errorLogStream = null;
  this.hooks = {};

  // init connect
  this.connect = connect();

  return this;
}


// register a hook
api.prototype.registerHook = function(hook, ifRouteOption, func) {
  if(!hook) throw new Error('no hook given');

  // ifRouteOption is optional
  if(_.isFunction(ifRouteOption)) {
    func = ifRouteOption;
    ifRouteOption = '*';
  }

  if(!_.has(this.hooks, hook)) 
    this.hooks[hook] = {};

  if(!_.has(this.hooks[hook], ifRouteOption))
    this.hooks[hook][ifRouteOption] = [];

  this.hooks[hook][ifRouteOption].push(func);
}

// convenience methods
api.prototype.beforeFunctionCall = function(ifRouteOption, func) {
  this.registerHook('beforeFunctionCall', ifRouteOption, func);
}
api.prototype.beforeRender = function(ifRouteOption, func) {
  this.registerHook('beforeRender', ifRouteOption, func);
}
api.prototype.beforeResponse = function(ifRouteOption, func) {
  this.registerHook('beforeResponse', ifRouteOption, func);
}
api.prototype.afterResponse = function(ifRouteOption, func) {
  this.registerHook('afterResponse', ifRouteOption, func);
}

api.prototype.setHandle = function(name, obj) {
  if(~['api', 'params', 'render', 'error', 'internalError'].indexOf(name)) throw new Error('unable to set ' + name + ' for $ (reserved)');
  this.handles[name] = obj;
}



api.prototype.listRoutes = function() {
  // init controllers if needed
  if(this.controllers === null) this.reload();
  return this.controllers;
}

api.prototype.reload = function() {

  // reset controllers stack
  this.controllers = {};  

  try {
    var files = fs.readdirSync(this.options.controllers);  
  } catch(e) {
    throw new Error('controllers directory not found: ' + this.options.controllers);
  }

  var filesLength = files.length;
  if(filesLength > 0) {
    for(var i=0; i < filesLength; i++) {
      var filePath = path.normalize(path.resolve(this.options.controllers) + '/' + files[i]);
      var fileName = path.basename(filePath, '.js');

      // load file
      try {
        var controller = require(filePath);
      } catch(e) {
        throw new Error('unable to load controller: ' + filePath);
      }

      // "parse" controller
      var signatures = Object.keys(controller);
      var signaturesLength = signatures.length;
      if(signaturesLength > 0) {
        for(var j=0; j < signaturesLength; j++) {
          var signature = signatures[j];
          var controllerFunction = controller[signature];

          // GET OPTION1 OPTION2 /controller/action/id
          var signatureParts = signature.split('/');
          var signaturePartsLength = signatureParts.length;
          if(signaturePartsLength < 2) throw new Error('invalid route signature ' + signature + " in " + filePath);

          // signatureParts[0] := GET OPTION1 OPTION2
          // signatureParts[1..n] := [controller, action, id]

          // parse http verb and options ...
          var meta = signatureParts.shift().split(' ');
          if(meta.length < 1) throw new Error('invalid route signature ' + signature + " in " + filePath);

          var verb = null;
          if(~HTTP_VERBS.indexOf(meta[0])) {
            verb = meta.shift();
          }
          if(!verb) throw new Error('invalid http verb in signature ' + signature + " in " + filePath);
          var options = _.without(meta, '');

          // parse route ...
          var routeParts = signatureParts;
          
          if(!_.has(this.controllers, fileName)) this.controllers[fileName] = [];

          // assign to global controllers stack
          this.controllers[fileName].push({
            verb: verb,
            options: options,
            route: routeParts,
            function: controllerFunction
          });

          // create magic aliases ...

          // add singular for plural controller
          // users -> user
          if(_.last(fileName) === 's') {
            if(!_.has(this.controllers, fileName.slice(0, -1))) 
              this.controllers[fileName.slice(0, -1)] = fileName;
          } 
          // add plurar for singular controller
          // user -> users
          else if(_.last(fileName) !== 's') {
            if(!_.has(this.controllers, fileName + 's')) 
              this.controllers[fileName + 's'] = fileName;
          }
        }
      }
    }
  }
};



api.prototype.start = function(readyCallback) {
  var that = this;

  // return X-Response-Time in response headers
  if(that.options.headersResponseTime) that.connect.use(connect.responseTime());

  // init controllers if needed
  if(that.controllers === null) that.reload();

  // enable error logging
  if(that.options.errorLog) {
    // @fixme: Date is wrong?!
    var date = new Date();
    that.errorLogStream = fs.createWriteStream(that.options.errorLog + '_' + date.getFullYear() + '_' + date.getMonth() + '_' + date.getDay(), {flags: 'a'});
  }

  // enable access logging
  // @todo files for different dates
  if(that.options.accessLog) {
    // @fixme: Date is wrong?!
    var date = new Date();
    var accessLogStream = fs.createWriteStream(that.options.accessLog + '_' + date.getFullYear() + '_' + date.getMonth() + '_' + date.getDay(), {flags: 'a'});
    that.connect.use(connect.logger({
      stream: accessLogStream, format: '[:date] :remote-addr :method :url :status (:response-time ms)'
    }));    
  }

  // enable cors?
  if(that.options.cors) that.connect.use(middlewareCors());

  // @INFO query and body is parsed before routing
  // for performance reasons, this could be done after
  // the routing process but before the actual
  // controller function is called in router.js
  // http://www.senchalabs.org/connect/query.html
  // http://www.senchalabs.org/connect/bodyParser.html
  that.connect.use(connect.query()); 
  that.connect.use(connect.bodyParser()); 
  
  // verify req variables for api attributes
  that.connect.use(function(req, res, next){
    if(_.has(req, 'api')) throw new Error('connect.req object has api property');
    if(_.has(res, 'api')) throw new Error('connect.res object has api property');

    req['api'] = [];
    res['api'] = [];

    next();
  });

  // parse route and make details in req available
  that.connect.use(middlewareRouter(that));

  // hook: beforeFunctionCall
  that.connect.use(middlewareHooks(that, 'beforeFunctionCall'));
  
  that.connect.use(middlewareCall(that)); // call func

  // hook: beforeRender
  that.connect.use(middlewareHooks(that, 'beforeRender'));

  // render controller function
  that.connect.use(middlewareRender(that));

  // enable jsonp support?
  if(that.options.jsonp)
    that.connect.use(middlewareJsonp(that));

  // hook: beforeResponse
  that.connect.use(middlewareHooks(that, 'beforeResponse'));

  // send response back to client
  that.connect.use(middlewareResponse(that));

  // hook: afterResponse
  that.connect.use(middlewareHooks(that, 'afterResponse'));

  // error handler
  that.connect.use(middlewareError(that));
  
  // start server and listen ...
  that.server = http.createServer(that.connect).listen(that.options.port, function() {
    util.log('[api] listening at port ' + that.options.port);
    if(readyCallback) return readyCallback.call(null);
  });

};

api.prototype.stop = function(stoppedCallback) {
  if(this.server) {
    this.server.close(function(){
      util.log('[api] server stopped');
      if(stoppedCallback) return stoppedCallback.call(null);
    })    
  }
  if(stoppedCallback) return stoppedCallback.call(null);
};

module.exports = api;
