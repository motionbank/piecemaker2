var _ = require('underscore');
var util = require('util');
var crypto = require('crypto');
var middlewareHooks = require('./hooks.js');


module.exports = function error(api) {
  return function(err, req, res, next) {

    // run cleanup function
    if(api.cleanupFunc) api.cleanupFunc.call(null, api);

    try {
      var ENV = 'development';

      // put everything in a try clause, because
      // errors happening here are sent to the client otherwise

      var errorCode = crypto.createHash('md5').update(new Date().toISOString()).digest('hex');

      // throw new ClientError({status: 404, message: 'xyz not found'})
      //  -> send message to client with status
      //  -> log error according to ENV

      // throw new Error('message')
      //  -> send status 500 to client
      //  -> log error according to ENV

      var contentParser = function(message, format) {
        return JSON.stringify(message); // @todo add global content parser
      }

      var errorLogger = function(status, error)
      {
        var now = new Date();

        switch(ENV) {
          case 'development':
            // log all statusCodes
            // log err.message, err.stack, datetime, request details

            // show in console
            
            util.error('------------------------------------------------------------');
            util.error('- ERROR - ' + now.toUTCString() + ' --------------------');
            util.error('- ' + errorCode + ' -------------------------');
            util.error('------------------------------------------------------------');

            if(req) {
              util.error('METHOD: ' + (req['method'] || undefined) + ' URL: ' + (req['url'] || undefined));
            }

            util.error(error.stack);

            if(req) {
              util.error('REQUEST HEADERS:');
              util.error(util.inspect(req.headers, false, 1, true));

              if(_.has(req, 'api')) {
                util.error('API INFO');
                util.error(util.inspect(req.api, false, 3, true));
              }              
            }

            util.error('\n');

            break;

          case 'production':
            // @todo this can be done better!
            // log internal server errors only
            if(status >= 500) {
              if(api.errorLogStream) {
                // log err.message, err.stack, datetime, request details

                api.errorLogStream.write('------------------------------------------------------------\n' +
                  '- ERROR - ' + now.toUTCString() + ' --------------------\n' +
                  '- ' + errorCode + ' -------------------------\n'+
                  'METHOD: ' + (req['method'] || undefined) + ' URL: ' + (req['url'] || undefined) + '\n' +
                  error.stack + '\n' +
                  'REQUEST HEADERS:\n' +
                  util.inspect(req.headers, false, 1, false) + '\n' +
                  'API INFO\n' + 
                  util.inspect(req.api, false, 3, false) + '\n\n');
              }
            }
            break;
        }
      }
      


      if(err instanceof ClientError) {
        // ClientError ...
        errorLogger(err.status, err);

        // try to guess the correct format
        var format = null;
        try {
          var format = req.api.request.format || req.headers.accept;
        } catch(e) {}
        if(!_.contains(FORMATS, format)) format = 'text/plain';
        res.setHeader('Content-Type', format);

        res.setHeader('X-API-Error-Code', errorCode);
        res.statusCode = err.status;

        // jsonp support
        try {
          if(req.api.options.jsonp) {
            return res.end(req.api.params.callback + '(' + contentParser(err.message, format) + ');');  
          } else {
            return res.end(contentParser(err.message, format));  
          }        
        } catch(e) {
          return res.end(contentParser(err.message, format));  
        }

      } else {
        // Error ...
        errorLogger(500, err);
        
        res.setHeader('X-API-Error-Code', errorCode);
        res.statusCode = 500;
        return res.end();
      }

    }
    catch(e) {
      // error handler has problems!!!!
      util.error('error.js has some serious issues if you see this!');
      util.error(e.stack);
      try {
        res.statusCode = 500;
        res.end();
      } catch(e) {
        // worst-case scenario .. ahhhh
        process.exit(1); // exit with a 'failure' code
      }
    }
  }
};